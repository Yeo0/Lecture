plot(dur,wait)
abline(rgweight, col="blue")
rewight$residual
rewight$residuals
reweight$residuals
rgweight$residuals
we_res=rgweight$residuals
plot(we_res)
predict(we_res)
?predict
predict(we_res)
as.numeric(we_res)
predict(as.numeric(we_res))
names(rgweight)
plot(we_res, rgweight$fitted.values )
plot(rg$residuals, rg$fitted.values)
plot(we_res, rgweight$fitted.values )
plot(rgweight$fitted.values,  we_res)
plot(rg$fitted.values, rg$residuals)
plot(rgweight$fitted.values, geyser$waiting)
plot(rg$fitted.values, geyser$waiting)
rgweight=lm(wait~dur, weights=(1/((dur - mean(dur))^2)))
rgweight
plot(rg$fitted.values, geyser$waiting , main="Using OLS")
plot(rgweight$fitted.values, geyser$waiting, main="Using WLS")
(dur - mean(dur))^2
rgweight=lm(wait~dur, weights=1/(dur - mean(dur))^2)
plot(rgweight$fitted.values, geyser$waiting, main="Using WLS")
plot(rg$fitted.values, geyser$waiting , main="Using OLS")
plot(rgweight$fitted.values,  we_res)
plot(rg$fitted.values, rg$residuals )
plot(geyser$waiting,  we_res)
plot(geyser$waiting, rg$residuals )
plot(geyser$waiting, rg$residuals, main="Using OLS" )
plot(geyser$waiting,  reweight$residuals,  main="Using WLS")
plot(geyser$waiting,  rgweight$residuals,  main="Using WLS")
mean(pred1$pred[-c(1:11)]) # 내년 평균 예측
mean(ann2014[,2]) #실제 2014년 평ㄱ
suns=read.table("C://Users//USER//Desktop//시계열 과제//sunspot2.txt")
head(suns); str(suns)
xt=sqrt(suns[,2])
tsxt=ts(xt)
difxt=diff(tsxt, differences=1)
acf(difxt,main="sample ACF, diff=1")
s_difxt = diff((difxt), lag=12, difference=1)
acf(s_difxt,main="sample ACF, diff=1")
s_difxt = diff((tsxt), lag=12, difference=1)
acf(s_difxt,main="sample ACF, diff=1")
plot(tsxt, main="series plot")
s_difxt = diff((tsxt), lag=12, difference=1)
plot(s_difxt, main="series plot, diff=4")
difxt=diff(tsxt, differences=1)
s_difxt = diff((difxt), lag=12, difference=1)
plot(s_difxt, main="series plot, diff=4")
par(mfrow=c(3,1))
plot(s_difxt, main="series plot, 계절차분+차부")
acf(s_difxt,main="sample ACF, 계절차분+차분")
pacf(s_difxt,main="sample PACF, 계절차분+차분")
ys=function(x){
x=1:x
return (mod(x)==0)
}
ys(12)
?mod
ys=function(x){
x=1:x
return (x%%x==0)
}
ys(12)
ys=function(x){
for(x in 1:x)
for(i in 1:x){
if(x%%i){
return(x%%i)
}
}
}
ys(12)
x=1:!2
x=1:12
x
x%%1:12
x%%2
x%%1
12%%1:ㅌ
12%%3
12%%1:ㅌ
12%%5
12%%1:
12%%5
12%%1:
12%%5
12%%1:
12%%5
12%%1
12%%5
ys=function(x){
a=c()
for(x in 1:x)
for(i in 1:x){
if(x%%i==0){
return(i)
}
}
}
ys(12)
ys=function(x){
a=c()
for(x in 1:x)
for(i in 1:x){
if(x%%i==0){
a[i]=i
}
}
return(a)
}
ys(12)
ys=function(x){
for(i in 1:x){
if(x%%i==0){
return(i)
}
}
}
ys(12)
ys=function(x){
for(i in 1:x){
if(x%%i==0){
return(i)
}
else break
}
}
ys(12)
if(12%%1==0){
return(i)
}
12%%1==0
for(i in 1:x){
if((12%%1==0)=T{
return(i)
}
x=1:12
x%%1
12의 약수 1,2,3,4,6,12
12/1:12 까지 중의 숫자를 했을때 나머지가 0임
12%%1
12%%5
ys=function(x){
a=c()
for(x in 1:x)
x%%1:x
}
}
}
ys(12)
?mod
ys=function(x){
for(i in 1:x){
if(x%%i==0)=T){
return(i)
}
}
}
x%%i==0)
return(1)
ys=function(x){
x=1:x
for(i in 1:x){
if(x%%i=0)){
return(i)
}
}
}
ys(12)
ys=function(x){
x=1:x
for(i in 1:x){
if(x%%i=0)){
return(i)
}
}
}
if(x%%i==0)){
return(i)
}
ys=function(x){
x=1:x
for(i in 1:x){
if(x%%i==0)){
return(i)
}
}
}
ys=function(x){
x=1:x
for(i in 1:x){
if(x%%i==0)){
return(i)
}
}
}
ys=function(x){
x=1:x
for(i in 1:x){
if(x%%i==0){
return(i)
}
}
}
ys(12)
ys=function(x){
p=1:x
for(i in 1:x){
if(x/i=p){
return(i)
}
}
return(i)
}
ys=function(x){
p=1:x
for(i in 1:x){
if((x/i)==p){
return(i)
}
}
return(i)
}
ys(12)
divisors <- function(number) {
x <- c(1:number)
for(i in 1:number){
if(number/i == c(x)) {
paste(i)
}
}
return(i)
}
divisors(12)
ys=function(x){
x=1:x
for(i in 1:x){
if((x%%i)==0){
return(i)
}
}
}
ys(12)
ys=function(x){
for(i in 1:x){
if((x%%i)==0){
if(TRUE) return(i)
}
}
}
ys(12)
arma11=arima.sim(list(order=c(1,0,1), ar=0.9, ma=0.5), n=2000, sd=1)
yeah=as.data.frame(matrix(arma11, nrow=200))
head(yeah)
mle_function=function(sigma,theta, pii){
(1/2)*log(2*pi*sigma^2*(1+theta^2))+((sum(yeah[1:99,1]-pii*yeah[2:100,1])^2)/(2*sigma^2*(1+theta^2)))
}
library(stats4)
mle(mle_function, list(sigma = 1, theta = 1, pii = 1), method = "CG")
for(i in 1:x){
if((12%%1==0)){
return(1)
}
x=1:12
x%%1
12의 약수 1,2,3,4,6,12
12/1:12 까지 중의 숫자를 했을때 나머지가 0임
12%%1
12%%5
ys=function(x){
a=c()
for(x in 1:x)
x%%1:x
}
}
for(i in 1:12){
if((12%%i)==0) print(i)
}
ys=function(x){
for(i in 1:x){
if((x%%i)==0){
print(i)
}
}
}
ys(12)
ys=function(x){
for(i in 1:x){
if((x%%i)==0){
print(i)
}
}
}
ys(36)
?arima.sim
ladjr <- leaps(V2+V3,y,method="adjr2")
lm(y~
library(leaps)
ladjr <- leaps(V2+V3,y,method="adjr2")
x=as.matrix(data2[,2:11])
y=data2$y
g=leaps(x,y, method="adjr2") #이게..각각의 결정계수들을 뽑은것 같은데..이래하면 안될껏 같고..
max(g$adjr2)
#####
calif=read.table("C://Users//USER//Desktop//회귀과제//hw//calif.txt", header=T)
head(calif)
str(calif)
head(calif, n=50)
attach(calif)
head(calif[order(longitude,latitude),], n=50)
plot(calif$longitude,calif$latitude,pch=21,
col=heat.colors(11)[11-floor(calif$value/50000)],
bg=heat.colors(11)[11-floor(calif$value/50000)],
cex=sqrt(calif$population/median(calif$population)),
xlab="Longitude",ylab="Latitude",main="Median House Prices")
legend(x="topright",legend=(50*(11:1)),fill=heat.colors(11))
value=calif$value
m_calif=calif[which(value==median(value)),]
par(mfrow=c(1,1))
lat=m_calif$latitude
long=m_calif$longitude
?points
points(long,lat, col="blue", pch=19)
?pch
# .위도, 경도를 제외한 모든 변수를 이용하여
# 주택가격의 분위수를 설명하는 선형회귀모형을 적합하고, 그 결과를 설명하시오.
names(calif)
head(calif[,1:7])
new_calif=calif[,1:7]
result=lm(value~., data=calif[,1:7])
summary(lm(value~., data=calif[,1:7]))
result
abline(result)
residual=result$residuals
new_calif=cbind(calif, residual)
head(new_calif)
res=result$residuals
summary(new_calif$residual)
par(mfrow=c(1,1))
install.packages("")
plot(new_calif$longitude,new_calif$latitude,pch=21,
col=heat.colors(20)[11-round(new_calif$residual/70000)],
bg=heat.colors(20)[11-round(new_calif$residual/70000)],
cex=sqrt(calif$population/median(calif$population)),
xlab="Longitude",ylab="Latitude",main="Median House Prices")
legend(x="topright",legend=(50*(11:1)),fill=heat.colors(11))
a = 1:20
hist(a, col = heat.colors(20), breaks = 1:20)
###########3
hist(calif$income) #이상치 발견!
hist(calif$rooms) #이
hist(calif$bedrooms)
hist(calif$population)
hist(calif$households)
summary(calif)
par(mfrow=c(1,6))
boxplot(calif$value, main="calif$value")
boxplot(calif$income,main="calif$income")
boxplot(calif$rooms, main="calif$rooms")
boxplot(calif$bedrooms, main="calif$bedrooms")
boxplot(calif$population, main="calif$population")
boxplot(calif$households, main="calif$households")
log_value=log(calif$value)
log_calif=data.frame(log_value, calif[,2:7])
rg_log_calif=lm(log_value~ . , data=log_calif)
summary(rg_log_calif)
plot(new_calif$longitude,new_calif$latitude,pch=21,
col=heat.colors(20)[11-round(rg_log_calif$residual/0.027)],
bg=heat.colors(20)[11-round(rg_log_calif$residual/0.02)],
cex=sqrt(calif$population/median(calif$population)),
xlab="Longitude",ylab="Latitude",main="Median House Prices")
legend(x="topright",legend=(50*(11:1)),fill=heat.colors(11))
summary(rg_log_calif$residuals)
library(leaps)
data2=read.table("C://Users//USER//Desktop//회귀과제//hw//data2.txt", header=T)
model1=lm((y~1, data))
model1=lm((y~1, data2))
head(data2)
rgg=lm(y~., data2)
re_rgg=drop1(rgg, test ="F")
re_rgg
?drop1
model2=lm(y~V2, data2)
model3=lm(y~V3, data2)
model4=lm(y~V4, data2)
model5=lm(y~V5, data2)
model6=lm(y~V6, data2)
model7=lm(y~V7, data2)
model8=lm(y~V8, data2)
model9=lm(y~V9, data2)
model10=lm(y~V10, data2)
model11=lm(y~V11, data2)
anova(full,model1)
full=lm(y~., data=data2)
anova(full,model1)
anova(full,model2)
summary(anova(full,model2))
g=leaps(x,y, method="adjr2") #이게..각각의 결정계수들을 뽑은것 같은데..이래하면 안될껏 같고..
x=as.matrix(data2[,2:11])
y=data2$y
g=leaps(x,y, method="adjr2") #이게..각각의 결정계수들을 뽑은것 같은데..이래하면 안될껏 같고..
g
summary(g)
x1=rep(1,200)
x2=data2[,2:11]
x=cbind(x1,x2)
x=as.matrix(x)
y=data2[,1]
projection(x)
yhat=y-(x%*%(solve(t(x)%*%x))%*%t(x)%*%y)
yhat
SSR=sum((yhat-mean(y))^2)
SST=sum((y-mean(y))^2)
SSE=SST-SSR
adr=1-(((n-1)*(SSE/SST))/(n-p-1))
adr
n=nrow(data2)
n
x1=rep(1,200)
x2=data2[,2:11]
x=cbind(x1,x2)
x=as.matrix(x)
y=data2[,1]
projection(x)
yhat=y-(x%*%(solve(t(x)%*%x))%*%t(x)%*%y)
yhat
SSR=sum((yhat-mean(y))^2)
SST=sum((y-mean(y))^2)
SSE=SST-SSR
adr=1-(((n-1)*(SSE/SST))/(n-p-1))
adr
p=ncol(data2)-1
p=ncol(data2)-1
n=nrow(data2)
x1=rep(1,200)
x2=data2[,2:11]
x=cbind(x1,x2)
x=as.matrix(x)
y=data2[,1]
projection(x)
yhat=y-(x%*%(solve(t(x)%*%x))%*%t(x)%*%y)
yhat
SSR=sum((yhat-mean(y))^2)
SST=sum((y-mean(y))^2)
SSE=SST-SSR
adr=1-(((n-1)*(SSE/SST))/(n-p-1))
adr
model2=lm(y~V2, data2)
model2
summary(model2)
summary(model2)
summary(model2)#________________________________
summary(model2)
names(summary(model2))
summary(model2)$adj.r.squared
adjrrr=function(n){
k=c()
for(n in 1:ncol(data2-1)){
k[n]=summary(lm(y~data2[,n], data2))$adj.r.squared
}
print(max(k))
}
k=c()
for(n in 1:ncol(data2-1)){
k[n]=summary(lm(y~data2[,n], data2))$adj.r.squared
}
result=max(k)
max(k)
for(n in 1:ncol(data2-1)){
k[n]=summary(lm(y~data2[,n+1], data2))$adj.r.squared
}
for(n in 1:ncol(data2-1)){
k[n]=summary(lm(y~data2[,(n+1)], data2))$adj.r.squared
}
ncol(data2)
names(data2[,2])
head(data2)
names(data2)
names(data2)[2]
k=c()
for(n in 1:(ncol(data2)-1)){
k[n]=summary(lm(y~data2[,n+1], data2))$adj.r.squared
}
k
result=max(k)
max(k)
which(k==max(k))
max(k)
k=c()
for(n in 1:(ncol(data2)-1)){
k[n]=summary(lm(y~data2[,n+1], data2))$adj.r.squared
}
max(k)
k
which(k==min(k))
k=c()
for(n in 1:(ncol(data2)-1)){
k[n]=summary(lm(y~data2[,n+1], data2))$adj.r.squared
}
which(k==max(k))
k
for(n in 1:(ncol(data2)-1)){
k[n]=summary(lm(y~data2[,n+1], data2))$adj.r.squared
}
k
which(k==max(k))
